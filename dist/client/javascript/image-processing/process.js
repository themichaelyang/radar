"use strict";

function process(context, video) {
  context.drawImage(video, 0, 0, video.videoWidth, video.videoHeight);
  var imageData = context.getImageData(0, 0, context.canvas.width, context.canvas.height);
  var width = context.canvas.width;
  var height = context.canvas.height;
  var data = imageData.data;

  // could use fast typed arrays for processing
  // https://hacks.mozilla.org/2011/12/faster-canvas-pixel-manipulation-with-typed-arrays/

  // colorNormalize(data);
  greyWorldNormalize(data);
  // colorDetection(data, [{r: 93, g:80, b:91}]);

  context.putImageData(imageData, 0, 0);
}

function colorDetection(data, colorProfile) {
  for (var i = 0; i < data.length; i += 4) {
    var r = data[i];
    var g = data[i + 1];
    var b = data[i + 2];

    for (var j = 0; j < colorProfile.length; j++) {
      if (colorDistance(colorProfile[j], { r: r, g: g, b: b }) < 10) {
        setColor(data, i, { r: 255, g: 255, b: 255 });
        break;
      } else {
        // could set after loop detects
        setColor(data, i, { r: 0, g: 0, b: 0 });
      }
    }
  }
}

function setColor(data, index, color) {
  data[index] = color.r;
  data[index + 1] = color.g;
  data[index + 2] = color.b;
}

// should set to direct r g b distances, i think this can introduce errors
function colorDistance(co, ct) {
  return Math.sqrt(Math.pow(co.r - ct.r, 2) + Math.pow(co.g - ct.g, 2) + Math.pow(co.b - ct.b, 2));
}

function indexToCoordinate(index, width) {
  var x = index % width;
  var y = (index - x) / width;
  return {
    x: x,
    y: y
  };
}

function coordinateToIndex(x, y, width) {
  return y * width + x;
}
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImphdmFzY3JpcHQvaW1hZ2UtcHJvY2Vzc2luZy9wcm9jZXNzLmpzIl0sIm5hbWVzIjpbInByb2Nlc3MiLCJjb250ZXh0IiwidmlkZW8iLCJkcmF3SW1hZ2UiLCJ2aWRlb1dpZHRoIiwidmlkZW9IZWlnaHQiLCJpbWFnZURhdGEiLCJnZXRJbWFnZURhdGEiLCJjYW52YXMiLCJ3aWR0aCIsImhlaWdodCIsImRhdGEiLCJncmV5V29ybGROb3JtYWxpemUiLCJwdXRJbWFnZURhdGEiLCJjb2xvckRldGVjdGlvbiIsImNvbG9yUHJvZmlsZSIsImkiLCJsZW5ndGgiLCJyIiwiZyIsImIiLCJqIiwiY29sb3JEaXN0YW5jZSIsInNldENvbG9yIiwiaW5kZXgiLCJjb2xvciIsImNvIiwiY3QiLCJNYXRoIiwic3FydCIsInBvdyIsImluZGV4VG9Db29yZGluYXRlIiwieCIsInkiLCJjb29yZGluYXRlVG9JbmRleCJdLCJtYXBwaW5ncyI6Ijs7QUFBQSxTQUFTQSxPQUFULENBQWlCQyxPQUFqQixFQUEwQkMsS0FBMUIsRUFBaUM7QUFDL0JELFVBQVFFLFNBQVIsQ0FBa0JELEtBQWxCLEVBQXlCLENBQXpCLEVBQTRCLENBQTVCLEVBQStCQSxNQUFNRSxVQUFyQyxFQUFpREYsTUFBTUcsV0FBdkQ7QUFDQSxNQUFJQyxZQUFZTCxRQUFRTSxZQUFSLENBQXFCLENBQXJCLEVBQXdCLENBQXhCLEVBQTJCTixRQUFRTyxNQUFSLENBQWVDLEtBQTFDLEVBQWlEUixRQUFRTyxNQUFSLENBQWVFLE1BQWhFLENBQWhCO0FBQ0EsTUFBSUQsUUFBUVIsUUFBUU8sTUFBUixDQUFlQyxLQUEzQjtBQUNBLE1BQUlDLFNBQVNULFFBQVFPLE1BQVIsQ0FBZUUsTUFBNUI7QUFDQSxNQUFJQyxPQUFPTCxVQUFVSyxJQUFyQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0FDLHFCQUFtQkQsSUFBbkI7QUFDQTs7QUFFQVYsVUFBUVksWUFBUixDQUFxQlAsU0FBckIsRUFBZ0MsQ0FBaEMsRUFBbUMsQ0FBbkM7QUFDRDs7QUFFRCxTQUFTUSxjQUFULENBQXdCSCxJQUF4QixFQUE4QkksWUFBOUIsRUFBNEM7QUFDMUMsT0FBSyxJQUFJQyxJQUFJLENBQWIsRUFBZ0JBLElBQUlMLEtBQUtNLE1BQXpCLEVBQWlDRCxLQUFLLENBQXRDLEVBQXlDO0FBQ3ZDLFFBQUlFLElBQUlQLEtBQUtLLENBQUwsQ0FBUjtBQUNBLFFBQUlHLElBQUlSLEtBQUtLLElBQUUsQ0FBUCxDQUFSO0FBQ0EsUUFBSUksSUFBSVQsS0FBS0ssSUFBRSxDQUFQLENBQVI7O0FBRUEsU0FBSyxJQUFJSyxJQUFJLENBQWIsRUFBZ0JBLElBQUlOLGFBQWFFLE1BQWpDLEVBQXlDSSxHQUF6QyxFQUE4QztBQUM1QyxVQUFJQyxjQUFjUCxhQUFhTSxDQUFiLENBQWQsRUFBK0IsRUFBQ0gsR0FBR0EsQ0FBSixFQUFPQyxHQUFHQSxDQUFWLEVBQWFDLEdBQUdBLENBQWhCLEVBQS9CLElBQXFELEVBQXpELEVBQTZEO0FBQzNERyxpQkFBU1osSUFBVCxFQUFlSyxDQUFmLEVBQWtCLEVBQUNFLEdBQUcsR0FBSixFQUFTQyxHQUFHLEdBQVosRUFBaUJDLEdBQUcsR0FBcEIsRUFBbEI7QUFDQTtBQUNELE9BSEQsTUFJSztBQUFFO0FBQ0xHLGlCQUFTWixJQUFULEVBQWVLLENBQWYsRUFBa0IsRUFBQ0UsR0FBRyxDQUFKLEVBQU9DLEdBQUcsQ0FBVixFQUFhQyxHQUFHLENBQWhCLEVBQWxCO0FBQ0Q7QUFDRjtBQUNGO0FBQ0Y7O0FBRUQsU0FBU0csUUFBVCxDQUFrQlosSUFBbEIsRUFBd0JhLEtBQXhCLEVBQStCQyxLQUEvQixFQUFzQztBQUNwQ2QsT0FBS2EsS0FBTCxJQUFjQyxNQUFNUCxDQUFwQjtBQUNBUCxPQUFLYSxRQUFNLENBQVgsSUFBZ0JDLE1BQU1OLENBQXRCO0FBQ0FSLE9BQUthLFFBQU0sQ0FBWCxJQUFnQkMsTUFBTUwsQ0FBdEI7QUFDRDs7QUFFRDtBQUNBLFNBQVNFLGFBQVQsQ0FBdUJJLEVBQXZCLEVBQTJCQyxFQUEzQixFQUErQjtBQUM3QixTQUFPQyxLQUFLQyxJQUFMLENBQVVELEtBQUtFLEdBQUwsQ0FBU0osR0FBR1IsQ0FBSCxHQUFPUyxHQUFHVCxDQUFuQixFQUFzQixDQUF0QixJQUEyQlUsS0FBS0UsR0FBTCxDQUFTSixHQUFHUCxDQUFILEdBQU9RLEdBQUdSLENBQW5CLEVBQXNCLENBQXRCLENBQTNCLEdBQXNEUyxLQUFLRSxHQUFMLENBQVNKLEdBQUdOLENBQUgsR0FBT08sR0FBR1AsQ0FBbkIsRUFBc0IsQ0FBdEIsQ0FBaEUsQ0FBUDtBQUNEOztBQUVELFNBQVNXLGlCQUFULENBQTJCUCxLQUEzQixFQUFrQ2YsS0FBbEMsRUFBeUM7QUFDdkMsTUFBSXVCLElBQUlSLFFBQVFmLEtBQWhCO0FBQ0EsTUFBSXdCLElBQUksQ0FBQ1QsUUFBUVEsQ0FBVCxJQUFjdkIsS0FBdEI7QUFDQSxTQUFPO0FBQ0x1QixPQUFHQSxDQURFO0FBRUxDLE9BQUdBO0FBRkUsR0FBUDtBQUlEOztBQUVELFNBQVNDLGlCQUFULENBQTJCRixDQUEzQixFQUE4QkMsQ0FBOUIsRUFBaUN4QixLQUFqQyxFQUF3QztBQUN0QyxTQUFRd0IsSUFBSXhCLEtBQUwsR0FBY3VCLENBQXJCO0FBQ0QiLCJmaWxlIjoiamF2YXNjcmlwdC9pbWFnZS1wcm9jZXNzaW5nL3Byb2Nlc3MuanMiLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBwcm9jZXNzKGNvbnRleHQsIHZpZGVvKSB7XG4gIGNvbnRleHQuZHJhd0ltYWdlKHZpZGVvLCAwLCAwLCB2aWRlby52aWRlb1dpZHRoLCB2aWRlby52aWRlb0hlaWdodCk7XG4gIGxldCBpbWFnZURhdGEgPSBjb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCBjb250ZXh0LmNhbnZhcy53aWR0aCwgY29udGV4dC5jYW52YXMuaGVpZ2h0KTtcbiAgbGV0IHdpZHRoID0gY29udGV4dC5jYW52YXMud2lkdGg7XG4gIGxldCBoZWlnaHQgPSBjb250ZXh0LmNhbnZhcy5oZWlnaHQ7XG4gIGxldCBkYXRhID0gaW1hZ2VEYXRhLmRhdGE7XG5cbiAgLy8gY291bGQgdXNlIGZhc3QgdHlwZWQgYXJyYXlzIGZvciBwcm9jZXNzaW5nXG4gIC8vIGh0dHBzOi8vaGFja3MubW96aWxsYS5vcmcvMjAxMS8xMi9mYXN0ZXItY2FudmFzLXBpeGVsLW1hbmlwdWxhdGlvbi13aXRoLXR5cGVkLWFycmF5cy9cblxuICAvLyBjb2xvck5vcm1hbGl6ZShkYXRhKTtcbiAgZ3JleVdvcmxkTm9ybWFsaXplKGRhdGEpO1xuICAvLyBjb2xvckRldGVjdGlvbihkYXRhLCBbe3I6IDkzLCBnOjgwLCBiOjkxfV0pO1xuXG4gIGNvbnRleHQucHV0SW1hZ2VEYXRhKGltYWdlRGF0YSwgMCwgMCk7XG59XG5cbmZ1bmN0aW9uIGNvbG9yRGV0ZWN0aW9uKGRhdGEsIGNvbG9yUHJvZmlsZSkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpICs9IDQpIHtcbiAgICBsZXQgciA9IGRhdGFbaV07XG4gICAgbGV0IGcgPSBkYXRhW2krMV07XG4gICAgbGV0IGIgPSBkYXRhW2krMl07XG5cbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNvbG9yUHJvZmlsZS5sZW5ndGg7IGorKykge1xuICAgICAgaWYgKGNvbG9yRGlzdGFuY2UoY29sb3JQcm9maWxlW2pdLCB7cjogciwgZzogZywgYjogYn0pIDwgMTApIHtcbiAgICAgICAgc2V0Q29sb3IoZGF0YSwgaSwge3I6IDI1NSwgZzogMjU1LCBiOiAyNTV9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBlbHNlIHsgLy8gY291bGQgc2V0IGFmdGVyIGxvb3AgZGV0ZWN0c1xuICAgICAgICBzZXRDb2xvcihkYXRhLCBpLCB7cjogMCwgZzogMCwgYjogMH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRDb2xvcihkYXRhLCBpbmRleCwgY29sb3IpIHtcbiAgZGF0YVtpbmRleF0gPSBjb2xvci5yO1xuICBkYXRhW2luZGV4KzFdID0gY29sb3IuZztcbiAgZGF0YVtpbmRleCsyXSA9IGNvbG9yLmI7XG59XG5cbi8vIHNob3VsZCBzZXQgdG8gZGlyZWN0IHIgZyBiIGRpc3RhbmNlcywgaSB0aGluayB0aGlzIGNhbiBpbnRyb2R1Y2UgZXJyb3JzXG5mdW5jdGlvbiBjb2xvckRpc3RhbmNlKGNvLCBjdCkge1xuICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KGNvLnIgLSBjdC5yLCAyKSArIE1hdGgucG93KGNvLmcgLSBjdC5nLCAyKSArIE1hdGgucG93KGNvLmIgLSBjdC5iLCAyKSk7XG59XG5cbmZ1bmN0aW9uIGluZGV4VG9Db29yZGluYXRlKGluZGV4LCB3aWR0aCkge1xuICBsZXQgeCA9IGluZGV4ICUgd2lkdGg7XG4gIGxldCB5ID0gKGluZGV4IC0geCkgLyB3aWR0aDtcbiAgcmV0dXJuIHtcbiAgICB4OiB4LFxuICAgIHk6IHlcbiAgfVxufVxuXG5mdW5jdGlvbiBjb29yZGluYXRlVG9JbmRleCh4LCB5LCB3aWR0aCkge1xuICByZXR1cm4gKHkgKiB3aWR0aCkgKyB4O1xufVxuIl19
